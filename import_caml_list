#!/usr/bin/perl -w
# Copyright (C) 2016-2018 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
use strict;
use warnings;
use Email::MIME;
$Email::MIME::ContentType::STRICT_PARAMS = 0; # user input is imperfect
use PublicInbox::Git;
use PublicInbox::Import;
use File::Basename;
my $usage = "usage: $0 CAML_LIST_DIR\n";
chomp(my $git_dir = `git rev-parse --git-dir`);
my $git = PublicInbox::Git->new($git_dir);
my $dir = shift or die $usage;
my $name = 'caml-list';
my $email = 'caml-list@inria.fr';
binmode STDIN;
my $msg = '';

# used to hash the relevant portions of a message when there are conflicts
sub _hash_mime2 {
	my ($mime) = @_;
	require Digest::SHA;
	my $dig = Digest::SHA->new('SHA-1');
	$dig->add($mime->header_obj->header_raw('Subject'));
	$dig->add($mime->body_raw);
	$dig->hexdigest;
}

sub _force_mid {
	my ($mime) = @_;
	# probably a bad idea, but we inject a Message-Id if
	# one is missing, here..
	my $mid = $mime->header_obj->header_raw('Message-Id');
	if (!defined $mid || $mid =~ /\A\s*\z/) {
		$mid = '<' . _hash_mime2($mime) . '@generated>';
                print "\nGENERATING mid = $mid\n";
		$mime->header_set('Message-Id', $mid);
	}
}

sub import_dir {
    my($dir) = @_;
    my $im = PublicInbox::Import->new($git, $name, $email);
    print "$dir (press key to continue)";
    <STDIN>;
    my @files = glob("$dir/*");
    @files = sort { basename($a) <=> basename($b) } @files;
    foreach my $file (@files) {
        my $base = basename($file);
        print "$base ";
        my $contents = `cat $file`;
        #print "$contents";
        $msg = Email::MIME->new($contents);
        _force_mid($msg);
        $im->add($msg) or print "(duplicate) ";
    };
    print "\n";
    $im->done;
}

foreach my $dir1 ( glob("$dir/caml-list_*-*") ) {
    import_dir($dir1)
}

# asctime: From example@example.com Fri Jun 23 02:56:55 2000
# my $from_strict = qr/^From \S+ \S+ \S+ +\S+ [^:]+:[^:]+:[^:]+ [^:]+/;
# my $prev = undef;
# while (defined(my $l = <STDIN>)) {
# 	if ($l =~ /$from_strict/o) {
# 		if (!defined($prev) || $prev =~ /^\r?$/) {
# 			do_add($im, \$msg) if $msg;
# 			$msg = '';
# 			$prev = $l;
# 			next;
# 		}
# 		warn "W[$.] $l\n";
# 	}
# 	$prev = $l;
# 	$msg .= $l;
# }
# do_add($im, \$msg) if $msg;
